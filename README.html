<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>DBIx::Squirrel - A module for working with databases</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:icampbell@eeyore.local" />
</head>

<body>



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#VERSION">VERSION</a></li>
  <li><a href="#SYNOPSIS">SYNOPSIS</a></li>
  <li><a href="#DESCRIPTION">DESCRIPTION</a>
    <ul>
      <li><a href="#Importing-the-package">Importing the package</a>
        <ul>
          <li><a href="#Database-Object-Helper-Functions">Database Object Helper Functions</a>
            <ul>
              <li><a href="#Examples">Examples</a></li>
            </ul>
          </li>
        </ul>
      </li>
      <li><a href="#Connecting-to-databases">Connecting to databases</a></li>
      <li><a href="#Preparing-statements">Preparing statements</a>
        <ul>
          <li>
            <ul>
              <li><a href="#Examples1">Examples</a></li>
            </ul>
          </li>
        </ul>
      </li>
      <li><a href="#Results-processing">Results processing</a></li>
    </ul>
  </li>
  <li><a href="#COPYRIGHT-AND-LICENSE">COPYRIGHT AND LICENSE</a></li>
  <li><a href="#SUPPORT-WARRANTY">SUPPORT / WARRANTY</a></li>
</ul>

<h1 id="NAME">NAME</h1>

<p>DBIx::Squirrel - A module for working with databases</p>

<h1 id="VERSION">VERSION</h1>

<p>version 1.2.2</p>

<h1 id="SYNOPSIS">SYNOPSIS</h1>

<pre><code># Simply use the package.

use DBIx::Squirrel;

$dbh = DBIx::Squirrel-&gt;connect($dsn, $user, $pass, \%attr);
$sth = $dbh-&gt;prepare(&#39;SELECT * FROM product WHERE id = ?&#39;);
$res = $sth-&gt;execute(&#39;1001099&#39;);
$itr = $sth-&gt;iterate(&#39;1001099&#39;);
while ($row = $itr-&gt;next) {...}

# Or, use it and have it create and import helper functions that
# you can use to interact with database objects.

use DBIx::Squirrel database_objects=&gt;[&#39;db&#39;, &#39;st&#39;, &#39;it&#39;];

db DBIx::Squirrel-&gt;connect($dsn, $user, $pass, \%attr);
st db-&gt;prepare(&#39;SELECT * FROM product WHERE id = ?&#39;);
$res = st-&gt;execute(&#39;1001099&#39;);
$res = st(&#39;1001099&#39;);  # Same as line above.
it st-&gt;iterate(&#39;1001099&#39;);
while ($row = it-&gt;next) {...}

# Clone another database connection.

$dbi = DBI-&gt;connect($dsn, $user, $pass, \%attr);
$dbh = DBIx::Squirrel-&gt;connect($dbi);

# Prepare a statement object.

$sth = $dbh-&gt;prepare($statement, \%attr);
$sth = $dbh-&gt;prepare_cached($statement, \%attr, $if_active);

# Commonly used positional and named parameter placeholder schemes
# conveniently supported regardless of database driver in use.

$sth = $dbh-&gt;prepare(&#39;SELECT * FROM product WHERE id = ?&#39;);
$sth = $dbh-&gt;prepare(&#39;SELECT * FROM product WHERE id = ?1&#39;);
$sth = $dbh-&gt;prepare(&#39;SELECT * FROM product WHERE id = $1&#39;);
$sth = $dbh-&gt;prepare(&#39;SELECT * FROM product WHERE id = :1&#39;);
$sth = $dbh-&gt;prepare(&#39;SELECT * FROM product WHERE id = :id&#39;);

# Able to bind values to individual parameters for both positional
# and named placeholder schemes.

$sth-&gt;bind_param(1, &#39;1001099&#39;);
$sth-&gt;bind_param(&#39;:id&#39;, &#39;1001099&#39;);
$sth-&gt;bind_param(&#39;id&#39;, &#39;1001099&#39;);

# Bind multiple values to parameters in a single statement.

$sth-&gt;bind( &#39;1001099&#39;, ... );
$sth-&gt;bind( [ &#39;1001099&#39;, ... ] );
$sth-&gt;bind( &#39;:id&#39; =&gt; &#39;1001099&#39;, ... );
$sth-&gt;bind( id =&gt; &#39;1001099&#39;, ... );
$sth-&gt;bind( { &#39;:id&#39; =&gt; &#39;1001099&#39;, ... } );
$sth-&gt;bind( { id =&gt; &#39;1001099&#39;, ... } );

# Or just have the statement handle&#39;s or iterator&#39;s &quot;execute&quot;
# method bind all values to parameters by passing it the same
# arguments you would pass to &quot;bind&quot;.

$res = $obj-&gt;execute( &#39;1001099&#39;, ... );
$res = $obj-&gt;execute( [ &#39;1001099&#39;, ... ] );
$res = $obj-&gt;execute( &#39;:id&#39; =&gt; &#39;1001099&#39;, ... );
$res = $obj-&gt;execute( id =&gt; &#39;1001099&#39;, ... );
$res = $obj-&gt;execute( { &#39;:id&#39; =&gt; &#39;1001099&#39;, ... } );
$res = $obj-&gt;execute( { id =&gt; &#39;1001099&#39;, ... } );

# The database handle &quot;do&quot; method works as it does with DBI,
# with the exception that returns the result followed by the
# statement handle when called in list-context. This means
# we can use it to prepare and execute statements, before we
# fetch results. Be careful to use &quot;undef&quot; if passing named
# parameters in a hashref so they are not used as statement
# attributes. The new &quot;do&quot; is smart enough not to confuse
# other things as statement attributes.

($res, $sth) = $dbh-&gt;do(
    &#39;SELECT * FROM product WHERE id = ?&#39;, &#39;1001099&#39;
);
($res, $sth) = $dbh-&gt;do(
    &#39;SELECT * FROM product WHERE id = ?&#39;, [&#39;1001099&#39;]
);
($res, $sth) = $dbh-&gt;do(
    &#39;SELECT * FROM product WHERE id = :id&#39;, &#39;:id&#39; =&gt; &#39;1001099&#39;
);
($res, $sth) = $dbh-&gt;do(
    &#39;SELECT * FROM product WHERE id = :id&#39;, id =&gt; &#39;1001099&#39;
);
($res, $sth) = $dbh-&gt;do( # ------------ undef or \%attr
    &#39;SELECT * FROM product WHERE id = :id&#39;, undef,
    { &#39;:id&#39; =&gt; &#39;1001099&#39;}
);
($res, $sth) = $dbh-&gt;do( # ------------ undef or \%attr
    &#39;SELECT * FROM product WHERE id = :id&#39;, undef,
    { id =&gt; &#39;1001099&#39; },
);

# Statement objects can create iterators using the &quot;iterate&quot;
# method (or its &quot;it&quot; alias). Use it as you would &quot;execute&quot;

$itr = $sth-&gt;iterate( &#39;1001099&#39; );
$itr = $sth-&gt;iterate([&#39;1001099&#39;]);

$itr = $sth-&gt;iterate( &#39;1001099&#39; );
$itr = $sth-&gt;iterate([&#39;1001099&#39;]);

$itr = $sth-&gt;iterate( &#39;1001099&#39; );
$itr = $sth-&gt;iterate([&#39;1001099&#39;]);

$itr = $sth-&gt;iterate( &#39;1001099&#39; );
$itr = $sth-&gt;iterate([&#39;1001099&#39;]);

$itr = $sth-&gt;iterate( &#39;1001099&#39; );
$itr = $sth-&gt;iterate([&#39;1001099&#39;]);

$itr = $sth-&gt;iterate( &#39;:id&#39; =&gt; &#39;1001099&#39; );
$itr = $sth-&gt;iterate( id =&gt; &#39;1001099&#39; );

$itr = $sth-&gt;iterate( { &#39;:id&#39; =&gt; &#39;1001099&#39; } );
$itr = $sth-&gt;iterate( { id =&gt; &#39;1001099&#39; } );

# Using the iterators couldn&#39;t be easier!

@ary = ();
while ($row = $itr-&gt;next) {
    push @ary, $row;
}

@ary = $itr-&gt;first;
push @ary, $_ while $itr-&gt;next;

@ary = $itr-&gt;first;
push @ary, $itr-&gt;remaining;

@ary = $itr-&gt;all;

$itr = $itr-&gt;reset;     # Repositions iterator at the start
$itr = $itr-&gt;reset({}); # Fetch rows as hashrefs
$itr = $itr-&gt;reset([]); # Fetch rows as arrayrefs

$row = $itr-&gt;single;
$row = $itr-&gt;single( id =&gt; &#39;1001100&#39; );
$row = $itr-&gt;single( { id =&gt; &#39;1001100&#39; } );
$row = $itr-&gt;find( id =&gt; &#39;1001100&#39; );
$row = $itr-&gt;find( { id =&gt; &#39;1001100&#39; } );

# A result set is just fancy subclass of the iterator. It will
# &quot;bless&quot; results, enabling us to get a column&#39;s value using an
# accessor methods, without ever having to worry about whether
# the row is a array or hash reference. While the accessor
# methods use lowercase names, they will access the column&#39;s
# value regardless of the case used.

$sth = $dbh-&gt;prepare(&#39;SELECT MediaTypeId, Name FROM media_types&#39;);
$res = $sth-&gt;results;
while ($res-&gt;next) {
    print $_-&gt;name, &quot;\n&quot;;
}

# Iterators allow for the use of lambda functions to process
# each row just in time during iteration.

$it = $sth-&gt;iterate(
    sub { $_-&gt;{Name} }
)-&gt;reset({});
print &quot;$_\n&quot; foreach $it-&gt;all;

# Lambdas may be chained.

$res = $sth-&gt;results(
    sub { $_-&gt;Name },
    sub { &quot;Media type: $_&quot; },
);
print &quot;$_\n&quot; while $res-&gt;next;

print &quot;$_\n&quot; for $dbh-&gt;results(
    q/SELECT MediaTypeId, Name FROM media_types/,
    sub { $_-&gt;Name },
)-&gt;all;

print &quot;$_\n&quot; for $dbh-&gt;select(&#39;media_types&#39;)-&gt;results(
    sub { $_-&gt;Name },
)-&gt;all;</code></pre>

<h1 id="DESCRIPTION">DESCRIPTION</h1>

<p>The <code>DBIx::Squirrel</code> package extends the <code>DBI</code>, by providing a few extra conveniences that are subtle and additive in nature, and, hopefully, quite useful.</p>

<h2 id="Importing-the-package">Importing the package</h2>

<p>In the simplest case, just import the package as you would any other:</p>

<pre><code>use DBIx::Squirrel;</code></pre>

<p>Any symbols and tags that you would typically import from the <code>DBI</code> can also be requested via <code>DBIx::Squirrel</code>:</p>

<pre><code>use DBIx::Squirrel DBI-IMPORT-LIST;</code></pre>

<p>If required (and in addition to any <code>DBI</code> imports), <code>DBIx::Squirrel</code> can create and import Database Object Helper functions for you:</p>

<pre><code>use DBIx::Squirrel database_object=&gt;NAME;
use DBIx::Squirrel database_objects=&gt;[NAMES];</code></pre>

<h3 id="Database-Object-Helper-Functions">Database Object Helper Functions</h3>

<p>A database object helper is nothing more than a standard function providing some syntactic sugar in the form of a polymorphic interface for interacting with database entities such as database connections, statements and iterators.</p>

<p>While it is not absolutely necessary to use them&mdash;you could just as easily use scalar references&mdash;helper functions do possess the advantage of being shared more easily among package namespaces than, say, lexical variables.</p>

<p>Helper semantics deal with three common types of interaction:</p>

<ul>

<li><p><b>Establishing an association</b></p>

<p>Before it can be used, a helper must first be associated with a database entity. This is accomplished by passing the function single argument: a reference to the associated object.</p>

<p>Once established, associations are <i>sticky</i> and cannot easily be undone. You should take care to create them once only, in a sensible place.</p>

<p>Use Perl&#39;s standard importing mechanisms (as shown above) to share associations among different package namespaces.</p>

</li>
<li><p><b>Resolving an association</b></p>

<p>Fetching the reference to the associated database object is accomplished by calling the helper function without any arguments.</p>

<p>When no association exists in this scenario, a helper returns <code>undef</code>.</p>

</li>
<li><p><b>Addressing an association</b></p>

<p>Addressing an association amounts to doing something meaningful with it, and we accomplish this by calling the helper function with one or more arguments.</p>

<p>Once associated with a database object, a helper function will any arguments that are passed to it and send a version of these to the database object method that imbues meaning to the interaction.</p>

<p>Meaning in this context is determined by the type of association:</p>

<ul>

<li><p>for a database connection, a statement is prepared using the <code>prepare</code> method;</p>

</li>
<li><p>for statements and iterators, these are executed with the <code>execute</code> and <code>iterate</code> methods respectively.</p>

</li>
</ul>

<p><b>Clearly there is a paradox here</b>, which centres around those statements and iterators expecting <i>no bind-values</i>. In order to smooth-out this wrinkle, you can opt to enclose arguments inside an anonymous array or hash. When no bind-values are expected, you can coerce the helper into performing the execution by passing an empty array or hash reference. Alternatively, you could just resolve the association and call the relevant method manually.</p>

</li>
</ul>

<h4 id="Examples">Examples</h4>

<ul>

<li><p>Let us do a full worked example. We will connect to a database, create and work with two result sets, one of which expects a single bind-value. Some concepts will be expanded upon and improved later, but it might be helpful to dip a toe in the water ahead of time:</p>

<pre><code>use DBIx::Squirrel database_objects =&gt; [ qw/db artists artist/ ];

# Associate helper (&quot;db&quot;) with our database connection:

@connect_args = ( &#39;dbi:SQLite:dbname=chinook.db&#39;, &#39;&#39;, &#39;&#39;, { sqlite_unicode =&gt; 1 } );
db( DBIx::Squirrel-&gt;connect(@connection_args) );

# Resolve the database connection helper (&quot;db&quot;), using it to
# associate helpers (&quot;artist&quot; and &quot;artists&quot;) with different
# result sets:

artist( db-&gt;results(&#39;SELECT * FROM artists WHERE Name=? LIMIT 1&#39;) );
artists( db-&gt;results(&#39;SELECT * FROM artists&#39;) );

# Address the helper (&quot;artist&quot;), passing it a bind-value, to get
# the ArtistId of the artist whose name is &quot;Aerosmith&quot;.
#
# We could have called &quot;next&quot; to get the only matching record, but by
# calling &quot;single&quot; (or &quot;first&quot;) we can ensure that there are no warnings
# about dangling active statements emitted when we disconnect from the
# database.

print artist(&#39;Aerosmith&#39;)-&gt;single-&gt;ArtistId, &quot;\n&quot;;

# Iterate over the &quot;artists&quot; result set, printing the Name-column for
# each artist. We don&#39;t need to trigger execution manually because
# the &quot;next&quot; method will do that for us, if it is necessary.

while ( artists-&gt;next ) {
    print $_-&gt;Name, &quot;\n&quot;;
};</code></pre>

</li>
</ul>

<h2 id="Connecting-to-databases">Connecting to databases</h2>

<p>Connecting to a database using <code>DBIx::Squirrel</code> may be done exactly as it would when using the <code>DBI</code>&#39;s <code>connect_cached</code> and <code>connect</code> methods.</p>

<p>The <code>connect</code> method implemented by the <code>DBIx::Squirrel</code> package does, however, offer an alternative form:</p>

<pre><code>$new_dbh = DBIx::Squirrel-&gt;connect($original_dbh, \%attr);</code></pre>

<p>This form clones another connection object and returns a brand object that is blessed using the same class that invoked the <code>connect</code> method. Objects being cloned are allowed to be those created by the <code>DBI</code> or any of its subclasses, <code>DBIx::Squirrel</code> being one of those.</p>

<h2 id="Preparing-statements">Preparing statements</h2>

<p>Preparing a statement using <code>DBIx::Squirrel</code> may be done exactly as it would be done using the <code>DBI</code>&#39;s <code>prepare_cached</code> and <code>prepare</code> methods.</p>

<p>One nice quality-of-life feature offered by <code>DBIx::Squirrel</code>&#39;s own implementation of the <code>prepare_cached</code> and <code>prepare</code> methods is its support for a number of parameter placeholder styles:</p>

<ul>

<li><p>named (<code>:name</code>);</p>

</li>
<li><p>positional (<code>:number</code>, <code>$number</code>, <code>?number</code>);</p>

</li>
<li><p>legacy (<code>?</code>)</p>

</li>
</ul>

<p>Regardless of your <code>DBD</code> driver and the style you opt to use for a statement, everything will be normalised to the legacy placeholder (<code>?</code>) by the time your statement is executed.</p>

<p>Use your preferred style or the style that most helps your query to be reasoned by others.</p>

<h4 id="Examples1">Examples</h4>

<ul>

<li><p>Legacy placeholders (<code>?</code>):</p>

<pre><code>$sth = $dbh-&gt;prepare(&#39;SELECT * FROM artists WHERE Name=? LIMIT 1&#39;);
$res = $sth-&gt;execute(&#39;Aerosmith&#39;);</code></pre>

</li>
<li><p>SQLite positional placeholders (<code>?number</code>):</p>

<pre><code>$sth = $dbh-&gt;prepare(&#39;SELECT * FROM artists WHERE Name=?1 LIMIT 1&#39;);
$res = $sth-&gt;execute(&#39;Aerosmith&#39;);</code></pre>

</li>
<li><p>PostgreSQL positional placeholders (<code>$number</code>):</p>

<pre><code>$sth = $dbh-&gt;prepare(&#39;SELECT * FROM artists WHERE Name=$1 LIMIT 1&#39;);
$res = $sth-&gt;execute(&#39;Aerosmith&#39;);</code></pre>

</li>
<li><p>Oracle positional placeholders (<code>:number</code>):</p>

<pre><code>$sth = $dbh-&gt;prepare(&#39;SELECT * FROM artists WHERE Name=:1 LIMIT 1&#39;);
$res = $sth-&gt;execute(&#39;Aerosmith&#39;);</code></pre>

</li>
<li><p>Oracle named placeholders (<code>:number</code>):</p>

<pre><code>$sth = $dbh-&gt;prepare(&#39;SELECT * FROM artists WHERE Name=:Name LIMIT 1&#39;);
$res = $sth-&gt;execute(Name =&gt; &#39;Aerosmith&#39;);</code></pre>

</li>
</ul>

<h2 id="Results-processing">Results processing</h2>

<ul>

<li><p>A <code>DBIx::Squirrel</code> statement can produce two kinds of iterator, to provide for efficient processing of results. These are generated using statement&#39;s <code>iterate</code> and <code>results</code> methods in place of <code>execute</code>.</p>

</li>
<li><p>Iterators offer a declarative way to process results using callbacks chains to transform results before they are returned to the caller.</p>

</li>
<li><p>Some DBIx-Squirrel iterator methods named <code>all</code>, <code>find</code>, <code>first</code>, <code>next</code>, <code>single</code> may already be familiar to <code>DBIx::Class</code> users, and they do similar jobs.</p>

</li>
</ul>

<h1 id="COPYRIGHT-AND-LICENSE">COPYRIGHT AND LICENSE</h1>

<p>The DBIx::Squirrel module is Copyright (c) 2020-2014 Iain Campbell. All rights reserved.</p>

<p>You may distribute under the terms of either the GNU General Public License or the Artistic License, as specified in the Perl 5.10.0 README file.</p>

<h1 id="SUPPORT-WARRANTY">SUPPORT / WARRANTY</h1>

<p>DBIx::Squirrel is free Open Source software. IT COMES WITHOUT WARRANTY OF ANY KIND.</p>


</body>

</html>


